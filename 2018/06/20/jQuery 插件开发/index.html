<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>jQuery 插件开发 | 起风了，唯有努力活下去；风起了，必须努力活下去</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="lzuliuyun"><meta name="designer" content="minfive"><meta name="keywords" content="lzuliuyun 前端 前端开发 程序员 node javascript js css angular react vue"><meta name="description" content="日常学习与兴趣交流的个人博客"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="http://lzuliuyun.com/2018/06/20/jQuery 插件开发/index.html"><link rel="icon" type="image/png" href="http://p66xl7flj.bkt.clouddn.com/favicon.ico" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="饿狼逐日"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?4c99cb602440c23e19d17380a9303f91";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(http://p66xl7flj.bkt.clouddn.com/load.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="饿狼逐日" alt="饿狼逐日"><img src="http://p66xl7flj.bkt.clouddn.com/logo.png" alt="饿狼逐日"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/demo" alt="作品" title="作品">作品</a></li><li class="nav__item"><a href="/music" alt="音乐" title="音乐">音乐</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><header class="post__info"><h1 class="post__title">jQuery 插件开发</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/">lzuliuyun</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2018-06-20</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/jquery/">Jquery</a></li><li class="mark__item"><a href="/tags/插件/">插件</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-eye"></i><ul class="mark__list clearfix"><li id="busuanzi_container_page_pv" class="mark__item"><span id="busuanzi_value_page_pv"></span>次</li></ul></div></div></header><div class="post__content"><blockquote><p>学习js开发，不可避免的接触jQuery,而在jQuery繁荣生态中，就免不了接触到插件的开发，本文则从初学者的角度阐述如何开发一个接口设计良好、扩展性强的插件。</p></blockquote></div><div class="post__content"><h2 id="1-jQuery-插件命名规范"><a href="#1-jQuery-插件命名规范" class="headerlink" title="1. jQuery 插件命名规范"></a>1. jQuery 插件命名规范</h2><p>通常jQuery采用jquery.pluginName.js方式命名，min版本则采用jquery.pluginName.min.js 方式命名，采用这种命名方式方便开发人员在full版和min版之间进行切换。</p><h2 id="2-jQuery-插件开发模式"><a href="#2-jQuery-插件开发模式" class="headerlink" title="2.jQuery 插件开发模式"></a>2.jQuery 插件开发模式</h2><ul><li><strong>\$.extend() 扩展jQuery</strong></li><li><strong>\$.fn 向jQuery添加新的方法 (通过jQuery函数prototype属性别名jquery.fn进行扩展)</strong></li><li><strong>通过\$.widget()应用jQuery UI部件工厂方式创建</strong></li></ul><h3 id="2-1-extend-扩展模式"><a href="#2-1-extend-扩展模式" class="headerlink" title="2.1 \$.extend 扩展模式"></a>2.1 \$.extend 扩展模式</h3><p>静态函数\$.extend的作用是将一个或多个对象的内容合并到目标对象，有两种用法：</p><ol><li>jQuery.extend(target [,object1] [,objectN… ])</li><li>jQuery.extend([deep],target,object1 [,objectN… ])</li></ol><p>用法二是用法一的变体，参数deep用于指示是否深度递归合并。</p><p><strong>说明：</strong></p><ul><li>该函数复制的对象属性包括方法在内。此外，还会复制对象继承自原型中的属性(JS内置的对象除外)；</li><li>参数deep的默认值为false，你可以为该参数明确指定true值，但不能明确指定false值。简而言之，第一个参数不能为false值；</li><li>如果参数为null或undefined，则该参数将被忽略；</li><li><font color="red">如果只为$.extend()指定了一个参数，则意味着参数target被省略。此时，target就是jQuery对象本身。通过这种方式，我们可以为全局对象jQuery添加新的函数；</font></li><li><font color="red">如果多个对象具有相同的属性，则后者会覆盖前者的属性值。</font></li></ul><blockquote><p>关于extend更深层次的用法见 <a href="http://www.365mini.com/page/jquery_extend.htm" target="_blank" rel="noopener">extend复制方法</a> ?</p></blockquote><p>最后两种特性用的最多，常用于插件默认设置合并等等；</p><p>通过extend扩展jquery命名空间，则是根据第四个特性，示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.extend(&#123;</span><br><span class="line">    sayHelloPlugin: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Hello,'</span> + (name ? name : <span class="string">'World'</span>) + <span class="string">'!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">$.sayHelloPlugin(); <span class="comment">//调用</span></span><br><span class="line">$.sayHelloPlugin(<span class="string">'World'</span>); <span class="comment">//带参调用</span></span><br></pre></td></tr></table></figure><p>也可以理解为在jQuery中添加全局函数,等同如下代码<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.sayHelloPlugin = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'Hello,'</span> + (name ? name : <span class="string">'World'</span>) + <span class="string">'!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br>1.jpg</p><p>如果有多个全局函数，那么写法如下：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.extend(&#123;</span><br><span class="line">    sayHelloPlugin : <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// put your code here</span></span><br><span class="line">    &#125; ,</span><br><span class="line">    sayWorldPlugin : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// put your code here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;) ;</span><br></pre></td></tr></table></figure><p></p><p>实际上写插件时，常用的写法是包裹在匿名函数中，代码如下<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;  </span><br><span class="line">    $.fn.extend(&#123;  </span><br><span class="line">        pluginName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">            <span class="comment">// put your code here</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;) ;  </span><br><span class="line">&#125;)(jQuery) ;</span><br></pre></td></tr></table></figure><p></p><p>综上，可见其原理都是通过对象合并扩展到jQuery命名空间中。这种方式定义一些辅助方法比较方便，比如定义一个自定义的console，输出特定格式的信息。典型的例子就是”$.ajax()”这个函数，将函数定义于jQuery的命名空间中。</p><p>？？？但是这种方式无法利用jQuery强大的选择器带来的便利，要处理DOM元素以及将插件更好的运用于所选择的元素上，还是需要使用第二种开发方式。你所见到或使用的插件也大多是通过此种方式开发。</p><p>###2.2 $.fn 原型继承模式###<br>通过原型继承模式，则直接添加动态属性到原型链上。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> (<span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;    </span><br><span class="line">     $.fn.pluginName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="comment">// put your code here </span></span><br><span class="line">    &#125; ;  </span><br><span class="line"> &#125;)(jQuery) ;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;  </span><br><span class="line">    $.fn.extend(&#123;  </span><br><span class="line">        pluginName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">            <span class="comment">// put your code here</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;) ;  </span><br><span class="line">&#125;)(jQuery) ;</span><br></pre></td></tr></table></figure><p>上面二者是等价的，对于一个jQuery插件，一个基本的函数就可以很好地工作，但是对于复杂一点的插件就需要提供各种各样的方法和私有函数。你可能会使用不同的命名空间去为你的插件提供各种方法，但是添加过多的命名空间反而会使代码变得混乱，健壮性下降。所以最好的解决办法是适当地定义私有函数和方法。所以我们通过自执行函数与闭包的结合实现模拟的私有插件单元，就像我们上面的实例中一样。</p><p>extend fn 区别？？<br>jQuery.fn = jQuery.prototype = { //jquery code goes here }</p><h3 id="2-3-jQuery-UI-部件工厂（Widget-Factory）"><a href="#2-3-jQuery-UI-部件工厂（Widget-Factory）" class="headerlink" title="2.3 jQuery UI 部件工厂（Widget Factory）"></a>2.3 jQuery UI 部件工厂（Widget Factory）</h3><p>Widget Factory是一个工厂方法，它接收两个或者三个参数：<br>第一个参数是一个名称空间，第二个参数是已有的widget原型，它将从该原型进行继承，第三个参数是一个可选的对象字面量，他作为新的widget原型；<br>Widget Factory 最简单的实现只需要一行代码<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> $.widget(<span class="string">'namespace.newsStuff'</span>,&#123;&#125;);</span><br></pre></td></tr></table></figure><p></p><p><strong>总结：如何选择开发模式</strong><br>通常使用第二种方法进行简单插件的开发；第三种开发更高级的jQuery部件的，该模式开发的插件带有jQuery内建的特性，比如插件的状态信息自动保存，各种关于插件的常用方法等；而第一种方式太简单，仅仅是在jQuery的命名空间或者理解成jQuery身上添加了一个静态方法而已,它通过调用\$.extend()添加的函数直接通过\$符号调用(\$.myFunction())，而不需要选中DOM元素(\$(‘example’).myFunction())</p><h2 id="3-jQuery-插件开发最佳实践"><a href="#3-jQuery-插件开发最佳实践" class="headerlink" title="3. jQuery 插件开发最佳实践"></a>3. jQuery 插件开发最佳实践</h2><h3 id="让插件接收参数"><a href="#让插件接收参数" class="headerlink" title="让插件接收参数"></a>让插件接收参数</h3><p>一个强劲的插件是可以让使用者随意定制的，这要求我们提供在编写插件时就要考虑得全面些，尽量提供合适的参数。比如现在我们不想让链接只变成红色，我们让插件的使用者自己定义显示什么颜色，要做到这一点很方便，只需要使用者在调用的时候传入一个参数即可。同时我们在插件的代码里面接收。另一方面，为了灵活，使用者可以不传递参数，插件里面会给出参数的默认值。</p><p>在处理插件参数的接收上，通常使用jQuery的extend方法，上面也提到过，但那是给extend方法传递单个对象的情况下，这个对象会合并到jQuery身上，所以我们就可以在jQuery身上调用新合并对象里包含的方法了，像上面的例子。</p><blockquote><p>当给extend方法传递一个以上的参数时，它会将所有参数对象合并到第一个里。同时，如果对象中有同名属性时，合并的时候后面的会覆盖前面的。</p></blockquote><p>利用这一点，我们可以在插件里定义一个保存插件参数默认值的对象，同时将接收来的参数对象合并到默认对象上，最后就实现了用户指定了值的参数使用指定的值，未指定的参数使用插件默认值。</p><p>为了演示方便，再指定一个参数fontSize，允许调用插件的时候设置字体大小。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$.fn.myPlugin = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> defaults = &#123;</span><br><span class="line">        <span class="string">'color'</span>: <span class="string">'red'</span>,</span><br><span class="line">        <span class="string">'fontSize'</span>: <span class="string">'12px'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> settings = $.extend(defaults, options);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.css(&#123;</span><br><span class="line">        <span class="string">'color'</span>: settings.color,</span><br><span class="line">        <span class="string">'fontSize'</span>: settings.fontSize</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们调用的时候指定颜色，字体大小未指定，会运用插件里的默认值12px。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'a'</span>).myPlugin(&#123;</span><br><span class="line">    <span class="string">'color'</span>: <span class="string">'#2C9929'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>同时指定颜色与字体大小：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'a'</span>).myPlugin(&#123;</span><br><span class="line">    <span class="string">'color'</span>: <span class="string">'#2C9929'</span>,</span><br><span class="line">    <span class="string">'fontSize'</span>: <span class="string">'20px'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><h3 id="保护好默认参数"><a href="#保护好默认参数" class="headerlink" title="保护好默认参数"></a>保护好默认参数</h3><p>注意到上面代码调用extend时会将defaults的值改变，这样不好，因为它作为插件因有的一些东西应该维持原样，另外就是如果你在后续代码中还要使用这些默认值的话，当你再次访问它时它已经被用户传进来的参数更改了。</p><p>一个好的做法是将一个新的空对象做为$.extend的第一个参数，defaults和用户传递的参数对象紧随其后，这样做的好处是所有值被合并到这个空对象上，保护了插件里面的默认值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$.fn.myPlugin = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> defaults = &#123;</span><br><span class="line">        <span class="string">'color'</span>: <span class="string">'red'</span>,</span><br><span class="line">        <span class="string">'fontSize'</span>: <span class="string">'12px'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> settings = $.extend(&#123;&#125;,defaults, options); <span class="comment">//将一个空对象做为第一个参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.css(&#123;</span><br><span class="line">        <span class="string">'color'</span>: settings.color,</span><br><span class="line">        <span class="string">'fontSize'</span>: settings.fontSize</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，插件可以接收和处理参数后，就可以编写出更健壮而灵活的插件了。若要编写一个复杂的插件，代码量会很大，如何组织代码就成了一个需要面临的问题，没有一个好的方式来组织这些代码，整体感觉会杂乱无章，同时也不好维护，所以将插件的所有方法属性包装到一个对象上，用面向对象的思维来进行开发，无疑会使工作轻松很多。</p><h3 id="面向对象的插件开发"><a href="#面向对象的插件开发" class="headerlink" title="面向对象的插件开发"></a>面向对象的插件开发</h3><p>为什么要有面向对象的思维，因为如果不这样，你可能需要一个方法的时候就去定义一个function，当需要另外一个方法的时候，再去随便定义一个function，同样，需要一个变量的时候，毫无规则地定义一些散落在代码各处的变量。还是老问题，不方便维护，也不够清晰。当然，这些问题在代码规模较小时是体现不出来的。如果将需要的重要变量定义到对象的属性上，函数变成对象的方法，当我们需要的时候通过对象来获取，一来方便管理，二来不会影响外部命名空间，因为所有这些变量名还有方法名都是在对象内部。</p><p>接着上面的例子，我们可以把这个插件抽象成一个美化页面的对象，因为他的功能是设置颜色啊字体啊什么的，当然我们还可以加入其他功能比如设置下划线啊什么的。当然对于这个例子抽象成对象有点小题大做，这里仅作演示用。以后我可能会介绍我编写的一个jQuery插件SlipHover,其中代码就比较多，这样的模式就用得上了。</p><p>所以我们新建一个对象命名为Beautifier，然后我们在插件里使用这个对象来编码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义Beautifier的构造函数</span></span><br><span class="line"><span class="keyword">var</span> Beautifier = <span class="function"><span class="keyword">function</span>(<span class="params">ele, opt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.$element = ele,</span><br><span class="line">    <span class="keyword">this</span>.defaults = &#123;</span><br><span class="line">        <span class="string">'color'</span>: <span class="string">'red'</span>,</span><br><span class="line">        <span class="string">'fontSize'</span>: <span class="string">'12px'</span>,</span><br><span class="line">        <span class="string">'textDecoration'</span>:<span class="string">'none'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">this</span>.options = $.extend(&#123;&#125;, <span class="keyword">this</span>.defaults, opt)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义Beautifier的方法</span></span><br><span class="line">Beautifier.prototype = &#123;</span><br><span class="line">    beautify: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$element.css(&#123;</span><br><span class="line">            <span class="string">'color'</span>: <span class="keyword">this</span>.options.color,</span><br><span class="line">            <span class="string">'fontSize'</span>: <span class="keyword">this</span>.options.fontSize,</span><br><span class="line">            <span class="string">'textDecoration'</span>: <span class="keyword">this</span>.options.textDecoration</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在插件中使用Beautifier对象</span></span><br><span class="line">$.fn.myPlugin = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//创建Beautifier的实体</span></span><br><span class="line">    <span class="keyword">var</span> beautifier = <span class="keyword">new</span> Beautifier(<span class="keyword">this</span>, options);</span><br><span class="line">    <span class="comment">//调用其方法</span></span><br><span class="line">    <span class="keyword">return</span> beautifier.beautify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面这样一改造，我们的代码变得更面向对象了，也更好维护和理解，以后要加新功能新方法，只需向对象添加新变量及方法即可，然后在插件里实例化后即可调用新添加的东西。</p><p>插件的调用还是一样的，我们对代码的改动并不影响插件其他地方，只是将代码的组织结构改动了而以。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'a'</span>).myPlugin(&#123;</span><br><span class="line">        <span class="string">'color'</span>: <span class="string">'#2C9929'</span>,</span><br><span class="line">        <span class="string">'fontSize'</span>: <span class="string">'20px'</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>指定文字带下划线（我们在Beautifier对象中新加的功能，默认不带下划线，如上面的例子）的调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'a'</span>).myPlugin(&#123;</span><br><span class="line">        <span class="string">'color'</span>: <span class="string">'#2C9929'</span>,</span><br><span class="line">        <span class="string">'fontSize'</span>: <span class="string">'20px'</span>,</span><br><span class="line">        <span class="string">'textDecoration'</span>: <span class="string">'underline'</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>到这里，你可以更好地编写复杂的插件同时很好地组织代码了。当我们回头去看上面的代码时，其实也还是有改进空间的。也就是下面介绍的关于命名空间及变量各什么的，一些杂项。</p><h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h3><p>在jQuery开发中，this关键字通常引用的是当前正在操作的DOM元素。但在当前的jQuery插件的上下文中，this关键字引用的是当前jQuery实例自身。因此在jQuery插件体内，\$.(this).toggle() 可以写为this.toggle();<br>在jQuery插件体内，将this关键字包装在\$()之中，实际上等效于$($(‘#element’))语句。唯一的例外当在jQuery遍历所有元素时。在\$.each()循环的循环体内，this关键字引用的是当前这一轮遍历时所暴露的DOM元素<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><br><span class="line">        $.fn.pinkify = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//this引用的是jQuery本身，即用jQuery选中的元素，紧接着调用了each()方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//对每个元素进行操作</span></span><br><span class="line">            $(<span class="keyword">this</span>).css(&#123;<span class="string">'color'</span>:<span class="string">'#fff'</span>&#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)(jQuery)</span><br></pre></td></tr></table></figure><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.fn.myPlugin = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在这里面this指的是jQuery选择的元素</span></span><br><span class="line">    <span class="comment">//example: $('a'),则this=$('a');</span></span><br><span class="line">    <span class="keyword">this</span>.css(<span class="string">'color'</span>,<span class="string">'red'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在插件名字定义的这个函数内部，this指代的是我们在调用该插件时，用jQuery选择器选中的元素，一般是一个jQuery类型的集合。比如$(‘a’)返回的是页面上所有a标签的集合，且这个集合已经是jQuery包装类型了，也就是说，在对其进行操作的时候可以直接调用jQuery的其他方法。而不需要再用美元符号来包装一下。所以在上面的插件代码中，我们在this身上调用的jQuery的css()方法，也就相当于在调用$(‘a’).css()。</p><h3 id="关于命名空间"><a href="#关于命名空间" class="headerlink" title="关于命名空间"></a>关于命名空间</h3><p>不仅仅是jQuery插件的开发，我们在写任何JS代码时都应该注意的一点是不要污染全局命名空间。因为随着你代码的增多，如果有意无意在全局范围内定义一些变量的话，最后很难维护，也容易跟别人写的代码有冲突。比如你在代码中向全局window对象添加了一个变量status用于存放状态，同时页面中引用了另一个别人写的库，也向全局添加了这样一个同名变量，最后的结果肯定不是你想要的。所以不到万不得已，一般我们不会将变量定义成全局的。</p><p>一个好的做法是始终用自<strong>调用匿名函数</strong>包裹你的代码，这样就可以完全放心，安全地将它用于任何地方了，绝对没有冲突。</p><h4 id="自调用匿名函数"><a href="#自调用匿名函数" class="headerlink" title="自调用匿名函数"></a>自调用匿名函数</h4><p>我们知道JavaScript中无法用花括号方便地创建作用域，但函数却可以形成一个作用域，域内的代码是无法被外界访问的。如果我们将自己的代码放入一个函数中，那么就不会污染全局命名空间，同时不会和别的代码冲突。</p><p>如上面我们定义了一个Beautifier全局变量，它会被附到全局的window对象上，为了防止这种事情发生，你或许会说，把所有代码放到jQuery的插件定义代码里面去啊，也就是放到\$.fn.myPlugin里面。这样做倒也是种选择。但会让我们实际跟插件定义有关的代码变得臃肿，而在$.fn.myPlugin里面我们其实应该更专注于插件的调用，以及如何与jQuery互动。</p><p>所以保持原来的代码不变，我们将所有代码用自调用匿名函数包裹。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//定义Beautifier的构造函数</span></span><br><span class="line">    <span class="keyword">var</span> Beautifier = <span class="function"><span class="keyword">function</span>(<span class="params">ele, opt</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.$element = ele,</span><br><span class="line">        <span class="keyword">this</span>.defaults = &#123;</span><br><span class="line">            <span class="string">'color'</span>: <span class="string">'red'</span>,</span><br><span class="line">            <span class="string">'fontSize'</span>: <span class="string">'12px'</span>,</span><br><span class="line">            <span class="string">'textDecoration'</span>: <span class="string">'none'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">this</span>.options = $.extend(&#123;&#125;, <span class="keyword">this</span>.defaults, opt)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义Beautifier的方法</span></span><br><span class="line">    Beautifier.prototype = &#123;</span><br><span class="line">        beautify: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.$element.css(&#123;</span><br><span class="line">                <span class="string">'color'</span>: <span class="keyword">this</span>.options.color,</span><br><span class="line">                <span class="string">'fontSize'</span>: <span class="keyword">this</span>.options.fontSize,</span><br><span class="line">                <span class="string">'textDecoration'</span>: <span class="keyword">this</span>.options.textDecoration</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在插件中使用Beautifier对象</span></span><br><span class="line">    $.fn.myPlugin = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//创建Beautifier的实体</span></span><br><span class="line">        <span class="keyword">var</span> beautifier = <span class="keyword">new</span> Beautifier(<span class="keyword">this</span>, options);</span><br><span class="line">        <span class="comment">//调用其方法</span></span><br><span class="line">        <span class="keyword">return</span> beautifier.beautify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p></p><p>这样做的好处，也就是上面所阐述的那样。另外还有一个好处就是，自调用匿名函数里面的代码会在第一时间执行，页面准备好过后，上面的代码就将插件准备好了，以方便在后面的代码中使用插件。</p><p>目前为止似乎接近完美了。如果再考虑到其他一些因素，比如我们将这段代码放到页面后，前面别人写的代码没有用分号结尾，或者前面的代码将window,undefined等这些系统变量或者关键字修改掉了，正好我们又在自己的代码里面进行了使用，那结果也是不可预测的，这不是我们想要的。我知道其实你还没太明白，下面详细介绍。</p><h4 id="支持链式调用"><a href="#支持链式调用" class="headerlink" title="支持链式调用"></a>支持链式调用</h4><p>我们都知道jQuery一个时常优雅的特性是支持链式调用，选择好DOM元素后可以不断地调用其他方法。</p><p>要让插件不打破这种链式调用，只需<strong>return</strong>一下即可。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.fn.myPlugin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//在这里面,this指的是用jQuery选中的元素</span></span><br><span class="line">    <span class="keyword">this</span>.css(<span class="string">'color'</span>, <span class="string">'red'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//对每个元素进行操作</span></span><br><span class="line">        $(<span class="keyword">this</span>).append(<span class="string">' '</span> + $(<span class="keyword">this</span>).attr(<span class="string">'href'</span>));</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="将系统变量以变量形式传递到插件内部"><a href="#将系统变量以变量形式传递到插件内部" class="headerlink" title="将系统变量以变量形式传递到插件内部"></a>将系统变量以变量形式传递到插件内部</h4><p>来看下面的代码，你猜他会出现什么结果？<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//别人的代码</span></span><br><span class="line">&#125;<span class="comment">//注意这里没有用分号结尾</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开始我们的代码。。。</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//我们的代码。。</span></span><br><span class="line">    alert(<span class="string">'Hello!'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p></p><p>本来别人的代码也正常工作，只是最后定义的那个函数没有用分号结尾而以，然后当页面中引入我们的插件时，报错了，我们的代码无法正常执行。原因是我们用来充当自调用匿名函数的第一对括号与上面别人定义的函数相连，因为中间没有分号嘛，总之我们的代码无法正常解析了，所以报错。</p><p>所以好的做法是我们在<strong>代码开头加一个分号</strong>，这在任何时候都是一个好的习惯。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//别人的代码</span></span><br><span class="line">&#125;<span class="comment">//注意这里没有用分号结尾</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开始我们的代码。。。</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//我们的代码。。</span></span><br><span class="line">    alert(<span class="string">'Hello!'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p></p><p>同时，将系统变量以参数形式传递到插件内部也是个不错的实践。</p><p>当我们这样做之后，window等系统变量在插件内部就有了一个局部的引用，可以提高访问速度，会有些许性能的提升,最后我们得到一个非常安全结构良好的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">$,window,document,undefined</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//我们的代码。。</span></span><br><span class="line">    <span class="comment">//blah blah blah...</span></span><br><span class="line">&#125;)(jQuery,<span class="built_in">window</span>,<span class="built_in">document</span>);</span><br></pre></td></tr></table></figure><p>而至于这个undefined，稍微有意思一点，为了得到没有被修改的undefined，我们并没有传递这个参数，但却在接收时接收了它，因为实际并没有传，所以‘undefined’那个位置接收到的就是真实的’undefined’了。是不是有点hack的味道，值得细细体会的技术，当然不是我发明的，都是从前人的经验中学习。???</p><p>增强模式：理解上面的写法<br>示范代码<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">$，window,docment,undefined</span>)</span>&#123;</span><br><span class="line">    $.fn.newStuff  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//your code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(jQuery,<span class="built_in">window</span>,<span class="built_in">document</span>)</span><br></pre></td></tr></table></figure><p></p><blockquote><p>该模式为增强模式，它为window和document对象创建了一个局部引用，并确保undefined保持undefined的值。增强模式具有更多的优点，比如为window、document创建的局部引用，可以是这两个对象在函数体内最精简？，还可以缩短要查询的表，从而在函数体内加快对这些对象的访问速度。</p></blockquote><p>所以最后我们的插件成了这样：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">$, window, document,undefined</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//定义Beautifier的构造函数</span></span><br><span class="line">    <span class="keyword">var</span> Beautifier = <span class="function"><span class="keyword">function</span>(<span class="params">ele, opt</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.$element = ele,</span><br><span class="line">        <span class="keyword">this</span>.defaults = &#123;</span><br><span class="line">            <span class="string">'color'</span>: <span class="string">'red'</span>,</span><br><span class="line">            <span class="string">'fontSize'</span>: <span class="string">'12px'</span>,</span><br><span class="line">            <span class="string">'textDecoration'</span>: <span class="string">'none'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">this</span>.options = $.extend(&#123;&#125;, <span class="keyword">this</span>.defaults, opt)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义Beautifier的方法</span></span><br><span class="line">    Beautifier.prototype = &#123;</span><br><span class="line">        beautify: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.$element.css(&#123;</span><br><span class="line">                <span class="string">'color'</span>: <span class="keyword">this</span>.options.color,</span><br><span class="line">                <span class="string">'fontSize'</span>: <span class="keyword">this</span>.options.fontSize,</span><br><span class="line">                <span class="string">'textDecoration'</span>: <span class="keyword">this</span>.options.textDecoration</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在插件中使用Beautifier对象</span></span><br><span class="line">    $.fn.myPlugin = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//创建Beautifier的实体</span></span><br><span class="line">        <span class="keyword">var</span> beautifier = <span class="keyword">new</span> Beautifier(<span class="keyword">this</span>, options);</span><br><span class="line">        <span class="comment">//调用其方法</span></span><br><span class="line">        <span class="keyword">return</span> beautifier.beautify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(jQuery, <span class="built_in">window</span>, <span class="built_in">document</span>);</span><br></pre></td></tr></table></figure><p></p><p>一个安全，结构良好，组织有序的插件编写完成。</p><h3 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h3><p>在jQuery插件开发中，常常需要遍历一个集合中的所有对象，并对每一个成员执行相应的操作。通常使用\$.each来实现对集合的遍历。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><br><span class="line">        $.fn.pinkify = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            $(<span class="keyword">this</span>).css(&#123;<span class="string">'color'</span>:<span class="string">'#fff'</span>&#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)(jQuery)</span><br></pre></td></tr></table></figure><p></p><p>但是在某些情况下，不必使用\$.each(),比如上面的例子，因为\$.css()本身就可以对集合中的每一个元素执行操作。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><br><span class="line">        $.fn.pinkify = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> $(<span class="keyword">this</span>).css(&#123;<span class="string">'color'</span>:<span class="string">'#fff'</span>&#125;);</span><br><span class="line">    &#125;)(jQuery)</span><br></pre></td></tr></table></figure><p></p><h3 id="关于变量定义及命名"><a href="#关于变量定义及命名" class="headerlink" title="关于变量定义及命名"></a>关于变量定义及命名</h3><p>现在谈谈关于变量及方法等的命名，没有硬性规定，但为了规范，遵循一些约定还是很有必要的。</p><p><strong>变量定义</strong>：好的做法是把将要使用的变量名用一个var关键字一并定义在代码开头，变量名间用逗号隔开。原因有二：</p><ol><li>便于理解，知道下面的代码会用到哪些变量，同时代码显得整洁且有规律，也方便管理，变量定义与逻辑代码分开；</li><li>是因为JavaScript中所有变量及函数名会自动提升，也称之为JavaScript的Hoist特性，即使你将变量的定义穿插在逻辑代码中，在代码解析运行期间，这些变量的声明还是被提升到了当前作用域最顶端的，所以我们将变量定义在一个作用域的开头是更符合逻辑的一种做法。当然，再次说明这只是一种约定，不是必需的。</li></ol><p><strong>变量及函数命名</strong> 一般使用驼峰命名法（CamelCase），即首个单词的首字母小写，后面单词首字母大写，比如resultArray，requestAnimationFrame。对于常量，所有字母采用大写，多个单词用下划线隔开，比如WIDTH=100，BRUSH_COLOR=’#00ff00’。当变量是jQuery类型时，建议以\$开头，开始会不习惯，但经常用了之后会感觉很方便，因为可以很方便地将它与普通变量区别开来，一看到以\$开头我们就知道它是jQuery类型可以直接在其身上调用jQuery相关的方法，比如var \$element=$(‘a’);之后就可以在后面的代码中很方便地使用它，并且与其他变量容易区分开来。</p><p><strong>引号的使用</strong> ：既然都扯了这些与插件主题无关的了，这里再多说一句，一般HTML代码里面使用双引号，而在JavaScript中多用单引号，比如下面代码所示：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Wayou'</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementById(‘example’).innerHTML = <span class="string">'&lt; a href="http: //wayouliu.duapp.com/"&gt;'</span>+name+<span class="string">'&lt;/a&gt;'</span>; <span class="comment">//href=".." HTML中保持双引号，JavaScript中保持单引号</span></span><br></pre></td></tr></table></figure><p></p><p>一方面，HTML代码中本来就使用的是双引号，另一方面，在JavaScript中引号中还需要引号的时候，要求我们单双引号间隔着写才是合法的语句，除非你使用转意符那也是可以的。再者，坚持这样的统一可以保持代码风格的一致，不会出现这里字符串用双引号包着，另外的地方就在用单引号。</p><h2 id="4-插件优化"><a href="#4-插件优化" class="headerlink" title="4. 插件优化"></a>4. 插件优化</h2><h2 id="5-代码混淆与压缩"><a href="#5-代码混淆与压缩" class="headerlink" title="5. 代码混淆与压缩"></a>5. 代码混淆与压缩</h2><p>进行完上面的步骤，已经小有所成了。或许你很早就注意到了，你下载的插件里面，一般都会提供一个压缩的版本一般在文件名里带个’min’字样。也就是minified的意思，压缩浓缩后的版本。并且平时我们使用的jQuery也是官网提供的压缩版本，jquery.min.js。</p><p>这里的压缩不是指代码进行功能上的压缩，而是通过将代码里面的变量名，方法函数名等等用更短的名称来替换，并且删除注释（如果有的话）删除代码间的空白及换行所得到的浓缩版本。同时由于代码里面的各种名称都已经被替代，别人无法阅读和分清其逻辑，也起到了混淆代码的作用。</p><p><strong>压缩的好处</strong></p><ul><li>源码经过混淆压缩后，体积大大减小，使代码变得轻量级，同时加快了下载速度，两面加载变快。比如正常jQuery v1.11.0的源码是276kb，而压缩后的版本仅94.1kb！体积减小一半还多。这个体积的减小对于文件下载速度的提升不可小觑。</li><li>经过压缩混淆后，代码还能阅读嘛？当然不能，所以顺带还起到了代码保护的作用。当然只是针对你编写了一些比较酷的代码又不想别人抄袭的情况。对于jQuery社区，这里本身就是开源的世界，同时JavaScript这东西其实也没什么实质性方法可以防止别人查看阅读你的代码，毕竟有混淆就有反混淆工具，这里代码压缩更多的还是上面提到的压缩文件的作用，同时一定程度上防止别人抄袭。</li></ul><p><strong>工具</strong><br>所使用的工具推崇的是Google开发的Closure Compiler。该工具需要Java环境的支持，所以使用前你可能需要先在机子上装JRE, 然后再获取Closure进行使用。<br>同时也有很朋在线的代码混淆压缩工具，用起来也很方便。这些工具都是一搜一大把的。</p><h2 id="6-插件发布"><a href="#6-插件发布" class="headerlink" title="6. 插件发布"></a>6. 插件发布</h2><p>这一步不是必需的，但本着把事情做完整的态度，同时你也许也希望有更多人看到或使用你的插件吧。</p><ul><li>首先你需要将插件代码放到GitHub上创建一个Service Hook，这样做的目的是你以后更新的插件后，jQuery可以自动去获取新版本的信息然后展示在插件中心的页面上。关于如何传代码到GitHub，你去下载GitHub 提供的客户端工具，就会知道如何操作了，非常方便。关于在GitHub创建Service Hook，也只是点几下而以的事情。下面会截图介绍。</li><li><p>然后需要制作一个JSON格式的清单文件，其中包括关于插件的基本信息，具体格式及参数可以在jQuery官网插件发布指南页面了解到，这里提供一个示例文件，是我之前写的一个jQuery插件SlipHover：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"sliphover"</span>,</span><br><span class="line">    <span class="string">"title"</span>: <span class="string">"SlipHover"</span>,</span><br><span class="line">    <span class="string">"description"</span>: <span class="string">"Apply direction aware  2D/3D hover effect to images"</span>,</span><br><span class="line">    <span class="string">"keywords"</span>: [</span><br><span class="line">        <span class="string">"direction-aware"</span>,</span><br><span class="line">        <span class="string">"animation"</span>,</span><br><span class="line">        <span class="string">"effect"</span>,</span><br><span class="line">        <span class="string">"hover"</span>,</span><br><span class="line">        <span class="string">"image"</span>,</span><br><span class="line">        <span class="string">"overlay"</span>,</span><br><span class="line">        <span class="string">"gallery"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"1.1.1"</span>,</span><br><span class="line">    <span class="string">"author"</span>: &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"Wayou"</span>,</span><br><span class="line">        <span class="string">"email"</span>: <span class="string">"liuwayong@gmail.com"</span>,</span><br><span class="line">        <span class="string">"url"</span>: <span class="string">"https://github.com/Wayou"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"maintainers"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="string">"name"</span>: <span class="string">"Wayou"</span>,</span><br><span class="line">            <span class="string">"email"</span>: <span class="string">"liuwayong@gmail.com"</span>,</span><br><span class="line">            <span class="string">"url"</span>: <span class="string">"https://github.com/Wayou"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"licenses"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"MIT"</span>,</span><br><span class="line">            <span class="string">"url"</span>: <span class="string">"https://github.com/jquery/jquery-color/blob/2.1.2/MIT-LICENSE.txt"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"bugs"</span>: <span class="string">"https://github.com/Wayou/sliphover/issues"</span>,</span><br><span class="line">    <span class="string">"homepage"</span>: <span class="string">"http://wayou.github.io/SlipHover/"</span>,</span><br><span class="line">    <span class="string">"docs"</span>: <span class="string">"http://wayou.github.io/SlipHover/"</span>,</span><br><span class="line">    <span class="string">"demo"</span>:<span class="string">"http://wayou.github.io/SlipHover/"</span>,</span><br><span class="line">    <span class="string">"download"</span>: <span class="string">"https://github.com/Wayou/SlipHover/zipball/master"</span>,</span><br><span class="line">    <span class="string">"dependencies"</span>: &#123;</span><br><span class="line">        <span class="string">"jquery"</span>: <span class="string">"&gt;=1.5"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后就可以在插件的根目录执行现行git代码来发布插件了。其中0.1.0是版本号，以后每次你的插件有新版本发布只需更新上面命令中的版本，创建新的tag，这样jQuery插件中心就会自动获取到新版本信息了<br>\$ git tag 0.1.0<br>\$ git push origin –tags</p></li></ul><div class="post-announce">感谢您的阅读，本文由 <a href="http://lzuliuyun.com">饿狼逐日</a> 版权所有。如若转载，请注明出处：饿狼逐日（<a href="http://lzuliuyun.com/2018/06/20/jQuery 插件开发/">http://lzuliuyun.com/2018/06/20/jQuery 插件开发/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2018/06/20/从零开始搭建个人博客/" title="从零开始搭建个人博客"><i class="iconfont icon-prev"></i>从零开始搭建个人博客</a></div><div class="post__prev post__prev--right"><a href="/2018/06/29/vim/" title="vim">vim<i class="iconfont icon-next"></i></a></div></div></div></article><div id="disqus_thread"></div></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="搜索..."> <i class="iconfont icon-search"></i></label></form><div id="toc" class="sidebar__block"><h3 class="block__title">目录</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-jQuery-插件命名规范"><span class="toc-number">1.</span> <span class="toc-text">1. jQuery 插件命名规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-jQuery-插件开发模式"><span class="toc-number">2.</span> <span class="toc-text">2.jQuery 插件开发模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-extend-扩展模式"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 \$.extend 扩展模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-jQuery-UI-部件工厂（Widget-Factory）"><span class="toc-number">2.2.</span> <span class="toc-text">2.3 jQuery UI 部件工厂（Widget Factory）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-jQuery-插件开发最佳实践"><span class="toc-number">3.</span> <span class="toc-text">3. jQuery 插件开发最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#让插件接收参数"><span class="toc-number">3.1.</span> <span class="toc-text">让插件接收参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#保护好默认参数"><span class="toc-number">3.2.</span> <span class="toc-text">保护好默认参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象的插件开发"><span class="toc-number">3.3.</span> <span class="toc-text">面向对象的插件开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this-关键字"><span class="toc-number">3.4.</span> <span class="toc-text">this 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关于命名空间"><span class="toc-number">3.5.</span> <span class="toc-text">关于命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#自调用匿名函数"><span class="toc-number">3.5.1.</span> <span class="toc-text">自调用匿名函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#支持链式调用"><span class="toc-number">3.5.2.</span> <span class="toc-text">支持链式调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#将系统变量以变量形式传递到插件内部"><span class="toc-number">3.5.3.</span> <span class="toc-text">将系统变量以变量形式传递到插件内部</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#遍历对象"><span class="toc-number">3.6.</span> <span class="toc-text">遍历对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关于变量定义及命名"><span class="toc-number">3.7.</span> <span class="toc-text">关于变量定义及命名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-插件优化"><span class="toc-number">4.</span> <span class="toc-text">4. 插件优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-代码混淆与压缩"><span class="toc-number">5.</span> <span class="toc-text">5. 代码混淆与压缩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-插件发布"><span class="toc-number">6.</span> <span class="toc-text">6. 插件发布</span></a></li></ol></div><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">日常学习与兴趣交流的个人博客</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/02-js/">02-js</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/03-develop/">03-develop</a><span class="block-list-count">2</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/04-backend/">04-backend</a><span class="block-list-count">2</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/05-database/">05-database</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/06-project/">06-project</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/07-linux/">07-linux</a><span class="block-list-count">3</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/08-tool/">08-tool</a><span class="block-list-count">1</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2018/07/09/图片上传/" title="图片上传"><div class="item__cover"><img src="http://p66xl7flj.bkt.clouddn.com/images/bbe00c2f-44fa-422d-9d20-3f622b7a253b.jpg?imageView2/0/q/75|watermark/1/image/aHR0cDovL3A2NnhsN2Zsai5ia3QuY2xvdWRkbi5jb20vbG9nby5wbmc=/dissolve/62/gravity/SouthEast/dx/20/dy/10|imageslim" alt="图片上传"></div><div class="item__info"><h3 class="item__title">图片上传</h3><span class="item__text">2018-07-09</span></div></a></li><li class="latest-post-item"><a href="/2018/07/09/图片裁剪/" title="图片裁剪"><div class="item__cover"><img src="http://p66xl7flj.bkt.clouddn.com/images/cecdc439-b231-4fc6-86ec-9d11350f43d0.jpg?imageView2/0/q/75|watermark/1/image/aHR0cDovL3A2NnhsN2Zsai5ia3QuY2xvdWRkbi5jb20vbG9nby5wbmc=/dissolve/62/gravity/SouthEast/dx/20/dy/10|imageslim" alt="图片裁剪"></div><div class="item__info"><h3 class="item__title">图片裁剪</h3><span class="item__text">2018-07-09</span></div></a></li><li class="latest-post-item"><a href="/2018/07/09/服务器部署笔记/" title="服务器部署笔记"><div class="item__cover"><img src="http://p66xl7flj.bkt.clouddn.com/images/d657a0ca-568d-4ccb-90a4-1ccde732b66c.jpg?imageView2/0/q/75|watermark/1/image/aHR0cDovL3A2NnhsN2Zsai5ia3QuY2xvdWRkbi5jb20vbG9nby5wbmc=/dissolve/62/gravity/SouthEast/dx/20/dy/10|imageslim" alt="服务器部署笔记"></div><div class="item__info"><h3 class="item__title">服务器部署笔记</h3><span class="item__text">2018-07-09</span></div></a></li><li class="latest-post-item"><a href="/2018/06/29/常用命令/" title="常用命令"><div class="item__cover"><img src="http://p66xl7flj.bkt.clouddn.com/images/bb192e6f-c866-427f-8c07-536444570df9.jpg?imageView2/0/q/75|watermark/1/image/aHR0cDovL3A2NnhsN2Zsai5ia3QuY2xvdWRkbi5jb20vbG9nby5wbmc=/dissolve/62/gravity/SouthEast/dx/20/dy/10|imageslim" alt="常用命令"></div><div class="item__info"><h3 class="item__title">常用命令</h3><span class="item__text">2018-06-29</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/centos/">centos</a></li><li class="tag-item"><a class="tag-link" href="/tags/jquery/">jquery</a></li><li class="tag-item"><a class="tag-link" href="/tags/linux/">linux</a></li><li class="tag-item"><a class="tag-link" href="/tags/mongodb/">mongodb</a></li><li class="tag-item"><a class="tag-link" href="/tags/nodejs/">nodejs</a></li><li class="tag-item"><a class="tag-link" href="/tags/npm/">npm</a></li><li class="tag-item"><a class="tag-link" href="/tags/vim/">vim</a></li><li class="tag-item"><a class="tag-link" href="/tags/上传/">上传</a></li><li class="tag-item"><a class="tag-link" href="/tags/图片/">图片</a></li><li class="tag-item"><a class="tag-link" href="/tags/插件/">插件</a></li><li class="tag-item"><a class="tag-link" href="/tags/数据库/">数据库</a></li><li class="tag-item"><a class="tag-link" href="/tags/服务器/">服务器</a></li><li class="tag-item"><a class="tag-link" href="/tags/编辑器/">编辑器</a></li><li class="tag-item"><a class="tag-link" href="/tags/裁剪/">裁剪</a></li><li class="tag-item"><a class="tag-link" href="/tags/运维/">运维</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">本站是基于 Hexo 搭建的静态资源博客，主要用于分享日常学习、生活及工作的一些心得总结，欢迎点击右下角订阅 rss。</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Shenzhen, Guangdong Province, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>lzuliuyun@163.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="http://p66xl7flj.bkt.clouddn.com/qrcode.png" alt="logo" title="饿狼逐日"></div><div class="footer-top__item"><h3 class="item__title">友情链接</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://juejin.im/timeline" title="开发者交流" target="_blank">掘金</a></li><li class="list-item"><a href="https://segmentfault.com" title="开发者交流" target="_blank">segmentfault</a></li><li class="list-item"><a href="https://www.cnblogs.com/" title="cnblogs" target="_blank">cnblogs</a></li><li class="list-item"><a href="https://www.qiniu.com" title="七牛云存储" target="_blank">七牛云</a></li></ul></div></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/lzuliuyun" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:lzuliuyun@163.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li><li class="social-network__item"><a href="https://www.zhihu.com/people/liu-yun-o-o-wei-wei/activities" target="_blank" title="zhihu"><i class="iconfont icon-zhihu"></i></a></li><li class="social-network__item"><a href="https://weibo.com/p/1005052488480654/home?from=page_100505_profile&wvr=6&mod=data#place" target="_blank" title="weibo"><i class="iconfont icon-weibo"></i></a></li><li class="social-network__item"><a href="https://www.douban.com/people/92808030/" target="_blank" title="douban"><i class="iconfont icon-douban"></i></a></li><li class="social-network__item"><a href="/atom.xml" target="_blank" title="rss"><i class="iconfont icon-rss"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script type="text/javascript" src="https://cdn.staticfile.org/jquery/1.4.2/jquery.min.js"></script><script type="text/javascript" src="http://p66xl7flj.bkt.clouddn.com/jquery.hashchange.plugin.js"></script><script src="/js/common.js"></script><script src="/js/page/post.js"></script><script>var disqus_shortname="true",disqus_config=function(){this.page.url="http://lzuliuyun.com/2018/06/20/jQuery 插件开发/",this.page.identifier="/2018/06/20/jQuery 插件开发/",this.page.title="jQuery 插件开发"};!function(){var t=document,e=t.createElement("script");e.src="https://"+disqus_shortname+".disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>